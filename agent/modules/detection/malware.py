"""
Malware detection module.
Scans for malicious software signatures and suspicious behaviors.
"""

import logging
import time
import os
import re
import hashlib
import json
from typing import Dict, List, Any, Optional
import uuid
import subprocess
import pathlib

class MalwareDetector:
    """
    Detects malware based on file signatures and system behaviors.
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize the malware detector.
        
        Args:
            config: Configuration dictionary
        """
        self.logger = logging.getLogger(__name__)
        self.config = config
        
        # Load malware signatures
        self.signatures_file = config.get("signatures_file", "data/signatures/malware_signatures.json")
        self.signatures = self._load_signatures()
        
        # Suspicious file extensions
        self.suspicious_extensions = config.get("suspicious_extensions", [
            ".exe", ".dll", ".bat", ".ps1", ".vbs", ".js", ".hta", 
            ".scr", ".pif", ".reg", ".com", ".cmd"
        ])
        
        # Directories to exclude from scanning
        self.exclude_dirs = config.get("exclude_dirs", [
            "C:\\Windows", "C:\\Program Files", "C:\\Program Files (x86)"
        ])
        
        # Scan configuration
        self.scan_depth = config.get("scan_depth", 3)  # Directory depth for quick scans
        self.hash_algorithm = config.get("hash_algorithm", "sha256")
        
        self.logger.info("Malware detector initialized")
    
    def _load_signatures(self) -> Dict[str, Any]:
        """
        Load malware signatures from file.
        
        Returns:
            Dictionary of malware signatures
        """
        signatures = {
            "hashes": {},
            "patterns": []
        }
        
        try:
            # Ensure the directory exists
            os.makedirs(os.path.dirname(self.signatures_file), exist_ok=True)
            
            # Try to load existing signatures file
            if os.path.exists(self.signatures_file):
                with open(self.signatures_file, 'r') as f:
                    signatures = json.load(f)
            else:
                # Create a new signatures file with some sample signatures
                sample_signatures = {
                    "hashes": {
                        "e1112134b6dcc8bed54e0e34d8ac272795e73d74": "WannaCry",
                        "7c465ea7bcccf4f94147add808f24629644be11c": "Emotet",
                        "5099a88478f2c90e3bbef304d0935aef13f6b4bb": "CryptoLocker"
                    },
                    "patterns": [
                        {"name": "Generic Ransomware", "pattern": "YOUR_FILES_ARE_ENCRYPTED"},
                        {"name": "Key Logger", "pattern": "GetAsyncKeyState|GetKeyboardState"},
                        {"name": "Process Injection", "pattern": "VirtualAllocEx.*WriteProcessMemory.*CreateRemoteThread"}
                    ]
                }
                with open(self.signatures_file, 'w') as f:
                    json.dump(sample_signatures, f, indent=2)
                signatures = sample_signatures
            
            self.logger.info(f"Loaded {len(signatures['hashes'])} hash signatures and {len(signatures['patterns'])} pattern signatures")
            
        except Exception as e:
            self.logger.error(f"Error loading malware signatures: {e}")
        
        return signatures
    
    def scan_file(self, file_path: str) -> Optional[Dict[str, Any]]:
        """
        Scan a single file for malware.
        
        Args:
            file_path: Path to the file to scan
        
        Returns:
            Detection result if malware is found, None otherwise
        """
        try:
            if not os.path.isfile(file_path):
                return None
            
            # Check file extension
            extension = os.path.splitext(file_path)[1].lower()
            is_suspicious = extension in self.suspicious_extensions
            
            # Calculate file hash
            hash_value = self._calculate_file_hash(file_path)
            if not hash_value:
                return None
            
            # Check against known malicious hashes
            malware_name = self.signatures["hashes"].get(hash_value)
            if malware_name:
                return {
                    "id": str(uuid.uuid4()),
                    "timestamp": time.time(),
                    "type": "malware_detected",
                    "source": file_path,
                    "severity": 5,  # Critical
                    "confidence": 0.95,
                    "details": {
                        "description": f"Known malware detected: {malware_name}",
                        "file_path": file_path,
                        "file_hash": hash_value,
                        "malware_name": malware_name,
                        "detection_type": "hash_match"
                    }
                }
            
            # For potentially suspicious files, perform content scanning
            if is_suspicious:
                # Check file size (skip very large files for performance)
                file_size = os.path.getsize(file_path)
                if file_size > 10 * 1024 * 1024:  # 10 MB
                    self.logger.debug(f"Skipping large file {file_path} ({file_size / 1024 / 1024:.2f} MB)")
                    return None
                
                # Scan file content for malicious patterns
                detection = self._scan_file_content(file_path)
                if detection:
                    return detection
            
        except Exception as e:
            self.logger.error(f"Error scanning file {file_path}: {e}")
        
        return None
    
    def _calculate_file_hash(self, file_path: str) -> Optional[str]:
        """
        Calculate the hash of a file.
        
        Args:
            file_path: Path to the file
        
        Returns:
            File hash or None if an error occurs
        """
        try:
            hash_alg = hashlib.new(self.hash_algorithm)
            
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b''):
                    hash_alg.update(chunk)
            
            return hash_alg.hexdigest()
            
        except Exception as e:
            self.logger.error(f"Error calculating hash for {file_path}: {e}")
            return None
    
    def _scan_file_content(self, file_path: str) -> Optional[Dict[str, Any]]:
        """
        Scan file content for malicious patterns.
        
        Args:
            file_path: Path to the file
        
        Returns:
            Detection result if malicious pattern is found, None otherwise
        """
        try:
            # Read file content
            with open(file_path, 'rb') as f:
                content = f.read()
            
            # Check against known malicious patterns
            for pattern_info in self.signatures["patterns"]:
                pattern = pattern_info["pattern"]
                if re.search(bytes(pattern, 'utf-8', errors='ignore'), content, re.IGNORECASE):
                    return {
                        "id": str(uuid.uuid4()),
                        "timestamp": time.time(),
                        "type": "malware_detected",
                        "source": file_path,
                        "severity": 4,  # High
                        "confidence": 0.80,
                        "details": {
                            "description": f"Suspicious pattern detected: {pattern_info['name']}",
                            "file_path": file_path,
                            "detection_type": "pattern_match",
                            "pattern_name": pattern_info["name"]
                        }
                    }
            
        except Exception as e:
            self.logger.error(f"Error scanning content of {file_path}: {e}")
        
        return None
    
    def quick_scan(self, target_dir: str = None) -> List[Dict[str, Any]]:
        """
        Perform a quick scan of the specified directory.
        
        Args:
            target_dir: Directory to scan, defaults to current user's home directory
        
        Returns:
            List of detected threats
        """
        threats = []
        
        if not target_dir:
            target_dir = os.path.expanduser("~")
        
        self.logger.info(f"Starting quick scan of {target_dir}")
        
        try:
            for root, dirs, files in os.walk(target_dir, topdown=True):
                # Skip excluded directories
                dirs[:] = [d for d in dirs if os.path.join(root, d) not in self.exclude_dirs]
                
                # Limit scan depth for quick scans
                if root.count(os.sep) - target_dir.count(os.sep) >= self.scan_depth:
                    dirs[:] = []
                    continue
                
                for file in files:
                    file_path = os.path.join(root, file)
                    detection = self.scan_file(file_path)
                    if detection:
                        threats.append(detection)
        
        except Exception as e:
            self.logger.error(f"Error during quick scan: {e}")
        
        self.logger.info(f"Quick scan completed, found {len(threats)} threats")
        return threats
    
    def deep_scan(self) -> List[Dict[str, Any]]:
        """
        Perform a deep scan of the system.
        This is a more thorough but slower scan.
        
        Returns:
            List of detected threats
        """
        # For brevity, this just wraps the quick_scan with a different target
        # In a real implementation, this would include more thorough scanning
        self.logger.info("Starting deep system scan")
        return self.quick_scan("C:\\")  # Start from root drive
